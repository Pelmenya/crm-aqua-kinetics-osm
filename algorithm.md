# Импорт OSM данных и Алгоритм построения топологии дорожной сети

## Импорт данных

### Шаг 1: Скачать дамп OSM данных

Перейдите на сайт [Geofabrik](https://download.geofabrik.de/russia.html) и выберите нужный вам регион, чтобы загрузить актуальный дамп данных в формате `.osm.pbf`.

### Шаг 2: Подключение к контейнеру

Подключитесь к вашему Docker-контейнеру с PostgreSQL и PostGIS, используя следующую команду:

```bash
docker exec -it postgres_postgis_osm bash
```

### Шаг 3: Выполнение команды ogr2ogr

Внутри контейнера выполните команду `ogr2ogr`, чтобы преобразовать и импортировать данные в базу данных PostgreSQL/PostGIS:

- Укажите файл с дампом с Geofabrik Server, в примере `central-fed-district-latest.osm.pbf`
- Укажите БД, в которую импортируем, в примере `aqua_kinetics_osm`

```bash
ogr2ogr \
    -f PGDUMP \
    /vsistdout/ "/data/central-fed-district-latest.osm.pbf" \
    -nln "osm_lines" \
    -nlt LINESTRING \
    -progress \
    --config PG_USE_COPY YES \
    --config GEOMETRY_NAME the_geom \
    --config OSM_COMPRESS_NODES YES \
    -sql "SELECT * FROM lines WHERE highway IS NOT NULL" \
    -lco FID=id \
    | psql -U postgres -d aqua_kinetics_osm
```

### Шаг 4: Проверка данных

После выполнения команды `ogr2ogr`, вы можете проверить, были ли данные успешно импортированы, подключившись к вашей базе данных, используя `psql` или `PgAdmin`, и выполнив запросы к таблице `osm_lines`.

Такой подход позволит вам использовать GDAL для более гибкого преобразования данных перед их загрузкой в базу данных, что может быть полезно для фильтрации или трансформации данных перед импортом. Убедитесь, что все зависимости и конфигурации настроены правильно, чтобы процесс прошел гладко.

## Создание топологии карты дорожной сети для импортированных данных

Для создания топологии используем функционал `pgRouting`.

### Шаг 1: Создание таблицы `ways` на основе `osm_lines`

```sql
DROP TABLE IF EXISTS ways;
CREATE TABLE ways AS
SELECT
  osm_id,
  name,
  highway,
  ST_Length(_ogr_geometry_::geography) AS length, -- Длина в метрах
  ST_StartPoint(_ogr_geometry_) AS start_point,   -- Начальная точка
  ST_EndPoint(_ogr_geometry_) AS end_point,       -- Конечная точка
  _ogr_geometry_ AS way                           -- Геометрия линии
FROM
  osm_lines
WHERE
  highway IN (                                    -- Только авто дороги. ВАЖНО!!! Иначе не построится сеть.
    'motorway',
    'motorway_link',
    'trunk',
    'trunk_link',
    'primary',
    'primary_link',
    'secondary',
    'secondary_link',
    'tertiary',
    'tertiary_link',
    'residential',
    'living_street',
    'unclassified',
    'road'
  );
```

### Шаг 2: Добавление столбцов для расчета топологии

```sql
-- Добавление необходимых столбцов
ALTER TABLE ways ADD COLUMN gid SERIAL PRIMARY KEY;
ALTER TABLE ways ADD COLUMN source INTEGER;
ALTER TABLE ways ADD COLUMN target INTEGER;
ALTER TABLE ways ADD COLUMN cost DOUBLE PRECISION;
ALTER TABLE ways ADD COLUMN reverse_cost DOUBLE PRECISION;
```

### Шаг 3: Установка стоимости на основе длины

```sql
UPDATE ways SET cost = length, reverse_cost = length;
```

### Шаг 4: Создание топологии и заполнение столбцов `source` и `target`

Важный параметр `tolerance = 0.000001`

```sql
SELECT pgr_createTopology('ways', 0.000001, 'way', 'gid');
```

#### Что такое `tolerance`?

`Tolerance` — это параметр, который указывает, насколько близко друг к другу должны быть точки (узлы) на линии, чтобы считаться одной и той же точкой (узлом) в топологии. Это значение измеряется в тех же единицах, что и геометрия данных, обычно в градусах, если ваши данные находятся в географической системе координат, такой как WGS 84.

#### Зачем нужен `tolerance`?

При работе с геометрическими данными, особенно с данными, импортированными из OSM, вы можете столкнуться с проблемами, связанными с неточностями в данных, такими как небольшие разрывы между линиями, которые должны быть соединены. Использование `tolerance` помогает объединить такие близкие точки в один узел, тем самым создавая более правильную и полезную топологию дорожной сети. Это особенно важно для корректного выполнения маршрутизации и других сетевых анализов.

#### Как выбрать значение для `tolerance`?

Выбор значения `tolerance` зависит от вашего масштаба и точности данных:

- **Малые значения (например, 0.000001):** Подходят для данных с высокой точностью, таких как данные OSM, где расстояния между узлами в географических координатах могут быть очень малы. Это значение соответствует примерно 0.1 метра на экваторе.
- **Большие значения:** Используются, если ваши данные имеют большую погрешность или если вы работаете с данными в проекциях, где единицы измерения в метрах.

### Шаг 5: Проверка топологии

```sql
SELECT * FROM pgr_connectedComponents(
  'SELECT gid AS id, source, target, cost FROM ways'
);
```

```sql
SELECT * FROM pgr_analyzeGraph('ways', 0.0001, 'way', 'gid');
```

### Шаг 6: Проверка кратчайшего пути

```sql
SELECT * FROM pgr_dijkstra(
  'SELECT gid AS id, source, target, cost FROM ways',
  1, 100, false
);
```

### Шаг 7: Алгоритм отладки

Для отладки и тестирования маршрутизации в вашем приложении вы можете использовать несколько точек из Центрального федерального округа России. В качестве примера можно использовать следующие координаты крупных городов:

Москва: 55.7558° N, 37.6173° E
Воронеж: 51.6608° N, 39.2003° E
Ярославль: 57.6261° N, 39.8845° E
Тула: 54.1931° N, 37.6176° E
Рязань: 54.6251° N, 39.7352° E

Создание и заполнение временной таблицы с этими точкамиВы можете использовать следующий SQL-запрос для создания временной таблицы и вставки этих точек:

```sql
-- Создание временной таблицы
CREATE TEMPORARY TABLE temp_points (id SERIAL PRIMARY KEY, geom GEOMETRY(Point, 4326));

-- Вставка координат точек
INSERT INTO temp_points (geom) VALUES (ST_SetSRID(ST_MakePoint(37.6173, 55.7558), 4326)); -- Москва
INSERT INTO temp_points (geom) VALUES (ST_SetSRID(ST_MakePoint(39.2003, 51.6608), 4326)); -- Воронеж
INSERT INTO temp_points (geom) VALUES (ST_SetSRID(ST_MakePoint(39.8845, 57.6261), 4326)); -- Ярославль
INSERT INTO temp_points (geom) VALUES (ST_SetSRID(ST_MakePoint(37.6176, 54.1931), 4326)); -- Тула
INSERT INTO temp_points (geom) VALUES (ST_SetSRID(ST_MakePoint(39.7352, 54.6251), 4326)); -- Рязань
```

Поиск ближайших узлов
После создания временной таблицы temp_points, вы можете выполнить запрос для нахождения ближайших узлов:

```sql
SELECT p.id, n.node_id
FROM temp_points p
JOIN LATERAL (
    SELECT
        w.source AS node_id, -- от источника или начала дороги, если брать gid не срабатывает
        ST_ClosestPoint(w.way, p.geom) AS closest_point
    FROM ways w
        WHERE ST_DWithin(p.geom, w.way, 0.01)
        ORDER BY ST_Distance(p.geom, w.way)
        LIMIT 1
    ) n ON true;
```

Результат

| id | node_id |
|----|:-------:|
|  1 | 580467  |
|  2 |  42512  |
|  3 | 685238  |
|  4 | 862817  |
|  5 | 168721  |

---

Создание матрицы расстояний
Найдите идентификаторы узлов и используйте эти идентификаторы для создания матрицы расстояний:

```sql
SELECT start_vid, end_vid, agg_cost AS cost
FROM pgr_dijkstraCost(
    'SELECT gid AS id, source, target, cost FROM ways',
    ARRAY[580467, 42512, 685238, 862817, 168721],
    ARRAY[580467, 42512, 685238, 862817, 168721]
)
WHERE start_vid <> end_vid;
```

Результат

| start_vid |  end_vid |          cost          |
|-----------|:--------:|:----------------------:|
|   42512   |  580467  |  511590.9200125901     |
|   42512   |  862817  |  762587.630814395      |
|  168721   |  42512   |  661304.8515993193     |
|  168721   |  580467  |  382112.3040575456     |
|  168721   |  862817  |  633109.01485935       |
|  580467   |  42512   |  515468.47716890834    |
|  580467   |  862817  |  293845.2817132866     |
|  862817   |  42512   |  343693.7128352452     |
|  862817   |  580467  |  190971.01145703974    |

---

Использование pgr_TSP
После получения матрицы расстояний используйте её для вызова pgr_TSP:

```sql

SELECT * FROM pgr_TSP(
'SELECT id, start_vid, end_vid, agg_cost FROM (
VALUES
(1, 42512, 580467, 511590.9200125901),
(2, 42512, 862817, 762587.630814395),
(3, 168721, 42512, 661304.8515993193),
(4, 168721, 580467, 382112.3040575456),
(5, 168721, 862817, 633109.01485935),
(6, 580467, 42512, 515468.47716890834),
(7, 580467, 862817, 293845.2817132866),
(8, 862817, 42512, 343693.7128352452),
(9, 862817, 580467, 190971.01145703974)
) AS dm (id, start_vid, end_vid, agg_cost)',
start_id := 42512
);
```

Результат

| seq |  node  |         cost         |        agg_cost         |
|-----|:------:|:--------------------:|:-----------------------:|
|  1  | 42512  |          0           |            0            |
|  2  | 862817 |  343693.7128352452   |   343693.7128352452     |
|  3  | 580467 |  190971.01145703974  |   534664.7242922849     |
|  4  | 168721 |  382112.3040575456   |   916777.0283498305     |
|  5  | 42512  |  661304.8515993193   |  1578081.8799491497     |

Выезжаем из Воронежа по всем городам выше и возвращаемся в него. Мин растояние обхода 1578 км 81 м.

---

### Шаг 8: Добавление индексов

Индексы на важные столбцы
Индекс на столбец gid: Хотя gid уже является первичным ключом, и индекс создается автоматически, это важно отметить.

```sql
-- Индекс на столбец `source`
CREATE INDEX idx_ways_source ON ways(source);

-- Индекс на столбец `target`
CREATE INDEX idx_ways_target ON ways(target);

-- Индекс на столбец `way` для ускорения пространственных запросов
CREATE INDEX idx_ways_way ON ways USING GIST(way);
```

## Альтернативный подход

Вы можете рассмотреть использование API [Project OSRM](https://project-osrm.org/docs/v5.24.0/api/?language=CLI#) для создания и работы с топологией дорожной сети.

### Вся инфраструктура в этом репозитории
